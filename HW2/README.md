# Homework #2

**1.** Реализовать классическое перемножение матриц и умножение матрицы на вектор на C/C++ с разным порядком циклов.

См. файлы `matmul/matmul.c`, `matmul/matmul.h` и `matmul/main.c`. Помимо предложенных в снипете методов перемножения, сюда добавил метод, идею которого взял из данной статьи https://habr.com/en/post/114797/. Чтобы подчеркнуть первоисточник, у данного метода суффикс `habr`.

**2.** Разбейте на модули, со статической линковкой скомпилируйте текст, подготовьте Makefile, проверьте флаги -g,  -O3.

См. файл `matmul/Makefile`. Также здесь провел сравнение времени выполнения перемножения в зависимости от флагов, передаваемых компилятору (см. таблицу ниже). 

*Время выполнения приведено в секундах.*
| *Алгоритм* | *Без флагов*  | *-O1*  | *-O2*  | *-O3*  |
| ------- | --- | --- | --- | --- |
| ijk | 11.2 | 3.3 | 3.4 | 3.1 |
| jik | 6.1 | 2.5 | 2.7 | 2.3 |
| kij | 3.3 | 0.7 | 0.7 | 0.5 |
| kij_opt | 3.1 | 0.7 | 0.7 | 0.5 |
| habr | 2.4 | 1.1 | 1.1 | 1.1 |

* Интересно, что без флагов оптимизации, метод `habr` быстрее всего выполняет умножение. При использовании оптимизации он уже не самый быстрый.
* Отличий между -O1 и -O2 особо нет. С оптимизацией -O3 самый быстрый результат. Стирается разница между методами `kij` и `kij_opt`.

**3.** Измерьте времена исполнения для размеров $N = 500, 512, 1000, 1024, 2000, 2048$.
В т.ч. проведите сравнение с виртуальной машиной, докером (опционально).

См. скрипт `exec_time_comparison.sh`.

Времена выполнения перемножений приведены в таблице ниже.

*Время выполнения приведено в секундах.*
| *Алгоритм* | *N=500*  | *N=512*  | *N=1000*  | *N=1024*  | *N=2000*  | *N=2048*  |
| ------- | --- | --- | --- | --- | --- | --- |
| ijk | 0.12 | 0.27 | 1.9 | 3.4 | 36.0 | 85.3 |
| jik | 0.12 | 0.28 | 1.4 | 2.7 | 27.4 | 68.9 |
| kij | 0.04 | 0.05 | 0.5 | 0.5 | 5.5 | 5.7 |
| kij_opt | 0.04 | 0.05 | 0.5 | 0.5 | 5.5 | 5.8 |
| habr | 0.11 | 0.12 | 1.0 | 1.1 | 9.2 | 10.5 |

* При увеличении *N* с 500 до 512, с 1000 до 1024 и с 2000 до 2048 время выполнения алгоритмов `ijk` и `jik` увечиливается вдвое. У остальных алгоритмов практически не меняется.

* При увеличении *N* в 2 раза время выполнения всех алгоритмов увеличивается на порядок.

**4.** *Базовые скрипты баш.*

См. файл `bash_base_script.sh`

**5.** *Бонус за линпак.*

Все коды и скрипты взяты отсюда: https://people.sc.fsu.edu/~jburkardt/c_src/linpack_bench/linpack_bench.html

Скрин теста производительности приведен ниже после **п.6**.

**6.** Супербонус протестируйте алгоритм Штрассена.

См. файлы `matmul/matmul_strassen.c`, `matmul/matmul_strassen.h`, `matmul/main_strassen.c` и `matmul/Makefile_Strassen`.

Времена выполнения данного алгоритма в зависимости от размера матрицы приведены ниже:

|| *N=512* | *N=1024* | *N=2048*  |
| ------- | --- | --- | --- |
| Время выполнения, с | 0.84 | 6.0 | 42.5 |

* Получилось не быстрее. Но, очень вероятно, что не оптимально реализовал. Доводил рекурсию до матрицы размера 2 на 2, хотя читал, что лучше при определнном размере перейти на классический алгоритм. Но при *N=2048* алгоритм работает быстрее, чем `ijk` и `jik`.

_______


![alt text](https://github.com/Dmitry-Galkin/HPC_homeworks/blob/main/HW2/linpack.png)

